diff --git a/clang/include/clang/Basic/BuiltinsRISCV.def b/clang/include/clang/Basic/BuiltinsRISCV.def
index 1528b18c82ea..713dceea2efd 100644
--- a/clang/include/clang/Basic/BuiltinsRISCV.def
+++ b/clang/include/clang/Basic/BuiltinsRISCV.def
@@ -89,5 +89,11 @@ TARGET_BUILTIN(__builtin_riscv_sm3p1, "UiUi", "nc", "zksh")
 TARGET_BUILTIN(__builtin_riscv_ntl_load, "v.", "t", "zihintntl")
 TARGET_BUILTIN(__builtin_riscv_ntl_store, "v.", "t", "zihintntl")
 
+TARGET_BUILTIN(__builtin_riscv_fmul_exp, "fff", "nc", "xnn")
+TARGET_BUILTIN(__builtin_riscv_fmul_exp_s, "fff", "nc", "xnn")
+TARGET_BUILTIN(__builtin_riscv_fmul_exp_m, "fff", "nc", "xnn")
+TARGET_BUILTIN(__builtin_riscv_fmul_exp_m_s, "fff", "nc", "xnn")
+
+
 #undef BUILTIN
 #undef TARGET_BUILTIN
diff --git a/llvm/include/llvm/IR/IntrinsicsRISCV.td b/llvm/include/llvm/IR/IntrinsicsRISCV.td
index 9a63d14b0ef0..85e731f52a19 100644
--- a/llvm/include/llvm/IR/IntrinsicsRISCV.td
+++ b/llvm/include/llvm/IR/IntrinsicsRISCV.td
@@ -633,7 +633,7 @@ let TargetPrefix = "riscv" in {
   class RISCVClassifyMasked
         : DefaultAttrsIntrinsic<[LLVMVectorOfBitcastsToInt<0>],
                     [LLVMVectorOfBitcastsToInt<0>, llvm_anyvector_ty,
-                     LLVMScalarOrSameVectorWidth<0, llvm_i1_ty>, 
+                     LLVMScalarOrSameVectorWidth<0, llvm_i1_ty>,
                      llvm_anyint_ty, LLVMMatchType<1>],
                     [IntrNoMem, ImmArg<ArgIndex<4>>]>, RISCVVIntrinsic {
     let VLOperand = 3;
@@ -1889,3 +1889,4 @@ let TargetPrefix = "riscv" in {
 include "llvm/IR/IntrinsicsRISCVXTHead.td"
 include "llvm/IR/IntrinsicsRISCVXsf.td"
 include "llvm/IR/IntrinsicsRISCVXCV.td"
+include "llvm/IR/IntrinsicsRISCVCustExtNN.td"
diff --git a/llvm/include/llvm/IR/IntrinsicsRISCVCustExtNN.td b/llvm/include/llvm/IR/IntrinsicsRISCVCustExtNN.td
new file mode 100644
index 000000000000..77d94cd1e360
--- /dev/null
+++ b/llvm/include/llvm/IR/IntrinsicsRISCVCustExtNN.td
@@ -0,0 +1,31 @@
+//===- IntrinsicsRISCV.td - Defines RISCV intrinsics -------*- tablegen -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines all of the RISCV-specific intrinsics.
+//
+//===----------------------------------------------------------------------===//
+
+//===----------------------------------------------------------------------===//
+// Float Exponent Intrinsics
+
+// For now support different kinds of exponent related floating point multiply
+// operations. These are approximate but can be used for machine learning
+// applications.
+let TargetPrefix = "riscv" in {
+
+  class FloatExpGPRGPRIntrinsics<string builtin_name>
+      : ClangBuiltin<builtin_name>,
+        Intrinsic<[llvm_float_ty],
+                              [llvm_float_ty, llvm_float_ty],
+                              [IntrNoMem]>;
+  def int_riscv_floatexp_mul : FloatExpGPRGPRIntrinsics<"__builtin_riscv_fmul_exp">;
+  def int_riscv_floatexp_mul_sign : FloatExpGPRGPRIntrinsics<"__builtin_riscv_fmul_exp_s">;
+  def int_riscv_floatexp_mul_man : FloatExpGPRGPRIntrinsics<"__builtin_riscv_fmul_exp_m">;
+  def int_riscv_floatexp_mul_man_sign : FloatExpGPRGPRIntrinsics<"__builtin_riscv_fmul_exp_m_s">;
+} // TargetPrefix = "riscv"
+
diff --git a/llvm/lib/Support/RISCVISAInfo.cpp b/llvm/lib/Support/RISCVISAInfo.cpp
index db2e4ca92ae4..29236e03025c 100644
--- a/llvm/lib/Support/RISCVISAInfo.cpp
+++ b/llvm/lib/Support/RISCVISAInfo.cpp
@@ -71,6 +71,7 @@ static const RISCVSupportedExtension SupportedExtensions[] = {
     {"xcvmac", {1, 0}},
     {"xcvmem", {1, 0}},
     {"xcvsimd", {1, 0}},
+    {"xnn", {1, 0}},
     {"xsfvcp", {1, 0}},
     {"xsfvfnrclipxfqf", {1, 0}},
     {"xsfvfwmaccqqq", {1, 0}},
diff --git a/llvm/lib/Target/RISCV/RISCVFeatures.td b/llvm/lib/Target/RISCV/RISCVFeatures.td
index 26451c80f57b..a3bc820cf4d1 100644
--- a/llvm/lib/Target/RISCV/RISCVFeatures.td
+++ b/llvm/lib/Target/RISCV/RISCVFeatures.td
@@ -785,6 +785,17 @@ def FeatureStdExtSvpbmt
 
 // Ventana Extenions
 
+// Patch generated by AUXO at 2024-03-20 21:21:04.315369
+// This is a custom CC NN feature
+def FeatureCustomExtNN
+  : SubtargetFeature<"xnn", "HasCustomExtNN", "true",
+                "NN (Compute Extension for Neural Network Inference)",
+                []>;
+
+def HasCustomExtNN : Predicate<"Subtarget->hasCustomExtNN()">,
+                           AssemblerPredicate<(all_of FeatureCustomExtNN),
+                           "NN (Compute Extension for Neural Network Inference)">;
+
 def FeatureVendorXVentanaCondOps
     : SubtargetFeature<"xventanacondops", "HasVendorXVentanaCondOps", "true",
                        "'XVentanaCondOps' (Ventana Conditional Ops)">;
diff --git a/llvm/lib/Target/RISCV/RISCVInstrInfo.td b/llvm/lib/Target/RISCV/RISCVInstrInfo.td
index 114329c2c7c5..c95d08c75e83 100644
--- a/llvm/lib/Target/RISCV/RISCVInstrInfo.td
+++ b/llvm/lib/Target/RISCV/RISCVInstrInfo.td
@@ -2179,6 +2179,7 @@ include "RISCVInstrInfoXVentana.td"
 include "RISCVInstrInfoXTHead.td"
 include "RISCVInstrInfoXSf.td"
 include "RISCVInstrInfoXCV.td"
+include "RISCVInstrInfoCustExtNN.td"
 
 //===----------------------------------------------------------------------===//
 // Global ISel
diff --git a/llvm/lib/Target/RISCV/RISCVInstrInfoCustExtNN.td b/llvm/lib/Target/RISCV/RISCVInstrInfoCustExtNN.td
new file mode 100644
index 000000000000..c2b453333e79
--- /dev/null
+++ b/llvm/lib/Target/RISCV/RISCVInstrInfoCustExtNN.td
@@ -0,0 +1,47 @@
+// Code generated by AUXO at 2024-03-20 21:21:04.314940;
+// Variable fields: ['rs2', 'rs1', 'rd']
+ // _r_0_"10F"_"01F"_"01F"_0_00xfe00707f
+class INSTR_nn_0xfe00707f_1 <bits<7> f0, bits<3> f1, RISCVOpcode opcode,  string opcodestr>
+: RVInstR<f0, f1, opcode, (outs FPR32:$rd),(ins FPR32:$rs1,FPR32:$rs2),opcodestr, "$rd, $rs1, $rs2"> {
+bits<5> rs2;
+bits<5> rs1;
+bits<5> rd;
+let Inst {24-20} = rs2;
+let Inst {19-15} = rs1;
+let Inst {11-7} = rd;
+let Inst {31-25} = f0;
+let Inst {14-12} = f1;
+let Inst {6-0} = opcode.Value;
+// let Opcode = opcode.Value;
+} // end of class INSTR_nn_0xfe00707f_1
+
+
+class NN_FPR_FPR_Pat<Intrinsic intrin, INSTR_nn_0xfe00707f_1 nnInst>
+    : Pat<(intrin FPR32:$rs1, FPR32:$rs2),
+          (nnInst FPR32:$rs1, FPR32:$rs2)>;
+
+def OPC_FMUL_EXP_M_S  : RISCVOpcode<"FMUL_EXP_M_S",    0b0001011>;
+
+      //===----------------------------------------------------------------------===//
+      // RISC-V specific DAG Nodes.
+      //===----------------------------------------------------------------------===//
+
+
+/* Use the same variable as defined in the RISCV.td for the extension as the predicate */
+let Predicates = [HasCustomExtNN] in {
+      /* set the values appropriately. use more than one group if there are different kinds of
+        instructions in the extension */
+let hasSideEffects=0, mayLoad=0, mayStore=0 in {
+def FMUL_EXP_M_S: INSTR_nn_0xfe00707f_1<0b1111100, 0b111, OPC_FMUL_EXP_M_S, "fmul_exp_m_s">;
+def FMUL_EXP_S: INSTR_nn_0xfe00707f_1<0b1011100, 0b111, OPC_FMUL_EXP_M_S, "fmul_exp_s">;
+def FMUL_EXP_M: INSTR_nn_0xfe00707f_1<0b1101100, 0b111, OPC_FMUL_EXP_M_S, "fmul_exp_m">;
+def FMUL_EXP: INSTR_nn_0xfe00707f_1<0b1001100, 0b111, OPC_FMUL_EXP_M_S, "fmul_exp">;
+}
+
+def FMUL_EXP_PAT : NN_FPR_FPR_Pat<int_riscv_floatexp_mul,FMUL_EXP>;
+def FMUL_EXP_S_PAT: NN_FPR_FPR_Pat<int_riscv_floatexp_mul_sign,FMUL_EXP_S>;
+def FMUL_EXP_M_PAT: NN_FPR_FPR_Pat<int_riscv_floatexp_mul_man,FMUL_EXP_M>;
+def FMUL_EXP_M_S_PAT: NN_FPR_FPR_Pat<int_riscv_floatexp_mul_man_sign,FMUL_EXP_M_S>;
+
+}
+ // end of predicates
\ No newline at end of file
diff --git a/llvm/lib/Target/RISCV/RISCVSubtarget.h b/llvm/lib/Target/RISCV/RISCVSubtarget.h
index 8c55efa69a6a..d5b2703aba4d 100644
--- a/llvm/lib/Target/RISCV/RISCVSubtarget.h
+++ b/llvm/lib/Target/RISCV/RISCVSubtarget.h
@@ -150,6 +150,7 @@ public:
   bool hasStdExtZfhminOrZhinxmin() const {
     return HasStdExtZfhmin || HasStdExtZhinxmin;
   }
+  // bool hasCustomExtNN() const { return HasCustomExtNN; }
   bool hasHalfFPLoadStoreMove() const {
     return HasStdExtZfhmin || HasStdExtZfbfmin;
   }
diff --git a/mlir/include/mlir/Conversion/ArithToRISCVNN/ArithToRISCVNN.h b/mlir/include/mlir/Conversion/ArithToRISCVNN/ArithToRISCVNN.h
new file mode 100644
index 000000000000..c15d5435bebf
--- /dev/null
+++ b/mlir/include/mlir/Conversion/ArithToRISCVNN/ArithToRISCVNN.h
@@ -0,0 +1,28 @@
+//===- ArithToRISCVNN.h - Math to LLVM dialect conversion -----------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef MLIR_CONVERSION_ARITHTORISCVNN_ARITHTORISCVNN_H
+#define MLIR_CONVERSION_ARITHTORISCVNN_ARITHTORISCVNN_H
+
+#include "mlir/Pass/Pass.h"  // from @llvm-project
+
+// Extra includes needed for dependent dialects
+#include "mlir/Dialect/Arith/IR/Arith.h"   // from @llvm-project
+#include "mlir/Dialect/Tensor/IR/Tensor.h"  // from @llvm-project
+namespace mlir {
+class ModuleOp;
+
+#define GEN_PASS_DECL_CONVERTARITHTORISCVNNPASS
+#include "mlir/Conversion/Passes.h.inc"
+
+/// Creates a pass to convert Math ops to SPIR-V ops.
+std::unique_ptr<OperationPass<>> createConvertArithToRISCVNN();
+
+}
+
+#endif // MLIR_CONVERSION_ARITHTORISCVNN_ARITHTORISCVNN_H
diff --git a/mlir/include/mlir/Conversion/Passes.h b/mlir/include/mlir/Conversion/Passes.h
index 0bfc5064c5dd..db8f3816124f 100644
--- a/mlir/include/mlir/Conversion/Passes.h
+++ b/mlir/include/mlir/Conversion/Passes.h
@@ -41,6 +41,7 @@
 #include "mlir/Conversion/LinalgToStandard/LinalgToStandard.h"
 #include "mlir/Conversion/MathToFuncs/MathToFuncs.h"
 #include "mlir/Conversion/MathToLLVM/MathToLLVM.h"
+#include "mlir/Conversion/ArithToRISCVNN/ArithToRISCVNN.h"
 #include "mlir/Conversion/MathToLibm/MathToLibm.h"
 #include "mlir/Conversion/MathToSPIRV/MathToSPIRVPass.h"
 #include "mlir/Conversion/MemRefToLLVM/MemRefToLLVM.h"
diff --git a/mlir/include/mlir/Conversion/Passes.td b/mlir/include/mlir/Conversion/Passes.td
index ec0a6284fe97..ad20ddb6b7df 100644
--- a/mlir/include/mlir/Conversion/Passes.td
+++ b/mlir/include/mlir/Conversion/Passes.td
@@ -693,6 +693,17 @@ def ConvertMathToLLVMPass : Pass<"convert-math-to-llvm"> {
   ];
 }
 
+//===----------------------------------------------------------------------===//
+// ArithToRISCVNN
+//===----------------------------------------------------------------------===//
+
+def ConvertArithToRISCVNNPass : Pass<"convert-arith-to-riscvnn"> {
+  let summary = "Convert math dialect operations to LLVM RISCV intrinsics for NN";
+  let dependentDialects = ["LLVM::LLVMDialect", "arith::ArithDialect"];
+  let constructor = "mlir::createConvertArithToRISCVNN()";
+}
+
+
 //===----------------------------------------------------------------------===//
 // MathToSPIRV
 //===----------------------------------------------------------------------===//
diff --git a/mlir/lib/Conversion/ArithToRISCVNN/ArithToRISCVNNPass.cpp b/mlir/lib/Conversion/ArithToRISCVNN/ArithToRISCVNNPass.cpp
new file mode 100644
index 000000000000..f00c20d64e27
--- /dev/null
+++ b/mlir/lib/Conversion/ArithToRISCVNN/ArithToRISCVNNPass.cpp
@@ -0,0 +1,207 @@
+//===- ArithToRISCVNNPass.cpp - Math to SPIR-V Passes ------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements a pass to convert standard dialect to SPIR-V dialect.
+//
+//===----------------------------------------------------------------------===//
+
+#include "mlir/Conversion/ArithToRISCVNN/ArithToRISCVNN.h"
+// #include <iostream>
+#include "mlir/Dialect/LLVMIR/LLVMAttrs.h"
+#include "mlir/Dialect/LLVMIR/LLVMTypes.h"
+#include "mlir/IR/BuiltinAttributes.h"
+#include "mlir/IR/BuiltinOps.h"
+#include "mlir/IR/BuiltinTypes.h"
+#include "mlir/Support/LLVM.h"
+#include "mlir/Support/LogicalResult.h"
+#include "mlir/Support/TypeID.h"
+
+#include "mlir/Target/LLVMIR/ModuleTranslation.h"
+#include "mlir/Conversion/AffineToStandard/AffineToStandard.h"
+#include "mlir/Conversion/ArithToLLVM/ArithToLLVM.h"
+#include "mlir/Conversion/ControlFlowToLLVM/ControlFlowToLLVM.h"
+#include "mlir/Conversion/FuncToLLVM/ConvertFuncToLLVM.h"
+#include "mlir/Conversion/FuncToLLVM/ConvertFuncToLLVMPass.h"
+#include "mlir/Conversion/LLVMCommon/ConversionTarget.h"
+#include "mlir/Conversion/LLVMCommon/TypeConverter.h"
+#include "mlir/Conversion/MemRefToLLVM/MemRefToLLVM.h"
+#include "mlir/Conversion/SCFToControlFlow/SCFToControlFlow.h"
+#include "mlir/Dialect/Arith/IR/Arith.h"
+#include "mlir/Dialect/Func/IR/FuncOps.h"
+#include "mlir/Dialect/LLVMIR/LLVMDialect.h"
+#include "mlir/Dialect/MemRef/IR/MemRef.h"
+#include "mlir/Dialect/SCF/IR/SCF.h"
+#include "mlir/Pass/Pass.h"
+#include "mlir/Transforms/DialectConversion.h"
+#include "mlir/Interfaces/InferTypeOpInterface.h"
+
+#include "llvm/Support/Casting.h"
+
+#include "llvm/ADT/STLExtras.h"
+#include "llvm/Support/Debug.h"
+#include "llvm/Support/FormatVariadic.h"
+#include "llvm/ADT/DenseMap.h"
+#include "llvm/ADT/SmallSet.h"
+#include "llvm/ADT/StringSet.h"
+#include "llvm/ADT/TypeSwitch.h"
+#include "llvm/Support/FormatVariadic.h"
+#include "llvm/Support/MathExtras.h"
+#include "llvm/Support/raw_ostream.h"
+
+#include <memory>
+#include <utility>
+
+
+namespace mlir {
+#define GEN_PASS_DEF_CONVERTARITHTORISCVNNPASS
+#include "mlir/Conversion/Passes.h.inc"
+} // namespace mlir
+
+using namespace mlir;
+
+// ************** Patterns **********
+static bool isSupportedSourceType(Type originalType) {
+  // https://github.com/llvm/llvm-project/blob/c5f839bd58e7f888acc4cb39a18e9e5bbaa9fb0a/mlir/lib/IR/Types.cpp#L123
+  if (originalType.isF32())
+    return true;
+  return false;
+}
+
+static LogicalResult checkSourceOpTypes(PatternRewriter &rewriter,
+                                        Operation *sourceOp) {
+  auto allTypes = llvm::to_vector(sourceOp->getOperandTypes());
+  llvm::append_range(allTypes, sourceOp->getResultTypes());
+
+  for (Type ty : allTypes) {
+    if (!isSupportedSourceType(ty)) {
+      return rewriter.notifyMatchFailure(
+          sourceOp,
+          llvm::formatv(
+              "unsupported source type for Math to SPIR-V conversion: {0}",
+              ty));
+    }
+  }
+  return success();
+}
+
+namespace {
+// lower arith.mulf{approx='exp|exp_sign|exp_man|exp_sign_man'}
+// to llvm intrinsic
+
+struct ApproxPattern : public OpRewritePattern<arith::MulFOp> {
+  ApproxPattern(MLIRContext *context) : OpRewritePattern<arith::MulFOp>(context) {}
+
+  // Define the match function to check if the operation has the "approx" attribute.
+  LogicalResult matchAndRewrite(arith::MulFOp op, PatternRewriter &rewriter) const override {
+    // Check if the operation has the "approx" attribute.
+    // std::cout << "mulf exp ?" << "\n";
+
+    StringAttr approxAttr = op->getAttrOfType<StringAttr>("approx");
+    if (!approxAttr || approxAttr.getValue() != "exp")
+      return failure();
+
+    if (LogicalResult res = checkSourceOpTypes(rewriter, op); failed(res))
+      return res;
+    // std::cout << "yay something matched" << "\n";
+
+    // Operation *llvmFMul = rewriter.create<LLVM::CallIntrinsicOp>(op.getLoc(), "llvm.riscv.floatexp.mul",
+    //     ArrayRef<Type>{op.getType()}, ArrayRef<Value>{op.getOperand(0), op.getOperand(1)});
+
+    // // Replace the arith.mulf operation with the llvm.fmul intrinsic call
+    // rewriter.replaceOp(op, llvmFMul->getResult(0));
+
+
+    // // If the "approx" attribute is "exp", rewrite the operation with an LLVM intrinsic call.
+    // // For example, replace it with llvm.exp.f32.
+    ModuleOp parentModule = op->getParentOfType<ModuleOp>();
+    auto fnName = "llvm.riscv.floatexp.mul";
+    // auto funcRef = getLLVMFuncRef(rewriter, parentModule, fnName);
+    auto context = parentModule->getContext();
+    auto llvmF32Ty = Float32Type::get(context); // 'mlir::Float32Type'
+
+    auto llvmFnType =  LLVM::LLVMFunctionType::get(
+      llvmF32Ty, // return type.
+      {llvmF32Ty, llvmF32Ty}, // parameter type.
+      false);
+
+    // Get a symbol reference to the printf function, inserting it if necessary.
+    auto printfRef = getLLVMFuncRef(rewriter, parentModule, fnName);
+
+    // Assuming op has operands that need to be passed as arguments
+    auto operands = op.getOperands();
+
+    // Create an array to hold the arguments for the LLVM::CallOp
+    SmallVector<Value, 4> args;
+    args.reserve(operands.size());
+
+    // Add operands as arguments
+    for (auto operand : operands) {
+        args.push_back(operand);
+    }
+    auto newOp = rewriter.create<LLVM::CallOp>(
+        op.getLoc(), llvmFnType, printfRef, args);
+
+    // Replace the original operation with the newly created LLVM intrinsic call.
+    rewriter.replaceOp(op, newOp->getResult(0));
+    return success();
+  }
+
+  static LLVM::LLVMFunctionType getFnType(MLIRContext *context) {
+    auto llvmF32Ty = Float32Type::get(context); // 'mlir::Float32Type'
+
+    auto llvmFnType =  LLVM::LLVMFunctionType::get(
+      llvmF32Ty, // return type.
+      {llvmF32Ty, llvmF32Ty}, // parameter type.
+      false);
+    return llvmFnType;
+  }
+  // / Return a symbol reference to the printf function, inserting it into the
+  // / module if necessary.
+  static FlatSymbolRefAttr getLLVMFuncRef(PatternRewriter &rewriter,
+                                             ModuleOp module,
+                                             std::string funcName) {
+    auto *context = module.getContext();
+    if (module.lookupSymbol<LLVM::LLVMFuncOp>(funcName))
+      return SymbolRefAttr::get(context, funcName);
+
+    // Insert the printf function into the body of the parent module.
+    PatternRewriter::InsertionGuard insertGuard(rewriter);
+    rewriter.setInsertionPointToStart(module.getBody());
+    rewriter.create<LLVM::LLVMFuncOp>(module.getLoc(), funcName,
+                                      getFnType(context));
+    return SymbolRefAttr::get(context, funcName);
+  }
+};
+
+}
+
+// ************** Patterns **********
+
+namespace {
+/// A pass converting MLIR Math operations into the SPIR-V dialect.
+class ConvertArithToRISCVNNPass
+    : public impl::ConvertArithToRISCVNNPassBase<ConvertArithToRISCVNNPass>  {
+
+  void runOnOperation() override;
+};
+} // namespace
+
+void ConvertArithToRISCVNNPass::runOnOperation() {
+  MLIRContext *context = &getContext();
+  LLVMConversionTarget target(*context);
+
+  RewritePatternSet patterns(context);
+  patterns.insert<ApproxPattern>(context);
+
+  if (failed(applyPartialConversion(getOperation(), target, std::move(patterns))))
+    return signalPassFailure();
+}
+
+std::unique_ptr<OperationPass<>> mlir::createConvertArithToRISCVNN() {
+  return std::make_unique<ConvertArithToRISCVNNPass>();
+}
diff --git a/mlir/lib/Conversion/ArithToRISCVNN/CMakeLists.txt b/mlir/lib/Conversion/ArithToRISCVNN/CMakeLists.txt
new file mode 100644
index 000000000000..e67b8ca448fb
--- /dev/null
+++ b/mlir/lib/Conversion/ArithToRISCVNN/CMakeLists.txt
@@ -0,0 +1,21 @@
+add_mlir_conversion_library(MLIRArithToRISCVNN
+  ArithToRISCVNNPass.cpp
+
+  ADDITIONAL_HEADER_DIRS
+  ${MLIR_MAIN_INCLUDE_DIR}/mlir/Dialect/Arith
+  ${MLIR_MAIN_INCLUDE_DIR}/mlir/Dialect/LLVM
+  ${MLIR_MAIN_INCLUDE_DIR}/mlir/IR
+
+  DEPENDS
+  MLIRConversionPassIncGen
+
+  LINK_LIBS PUBLIC
+  MLIRIR
+  MLIRArithDialect
+  MLIRMathDialect
+  MLIRLLVMDialect
+  MLIRPass
+  MLIRSupport
+  MLIRTransformUtils
+  )
+
diff --git a/mlir/lib/Conversion/CMakeLists.txt b/mlir/lib/Conversion/CMakeLists.txt
index 3a5dbc12c23f..190f20f674db 100644
--- a/mlir/lib/Conversion/CMakeLists.txt
+++ b/mlir/lib/Conversion/CMakeLists.txt
@@ -4,6 +4,7 @@ add_subdirectory(ArithCommon)
 add_subdirectory(ArithToAMDGPU)
 add_subdirectory(ArithToArmSME)
 add_subdirectory(ArithToLLVM)
+add_subdirectory(ArithToRISCVNN)
 add_subdirectory(ArithToSPIRV)
 add_subdirectory(ArmNeon2dToIntr)
 add_subdirectory(ArmSMEToSCF)
